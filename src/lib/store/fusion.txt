/* eslint-disable @typescript-eslint/no-explicit-any */
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { authApi } from '@/lib/api/auth';
import type { User, LoginInput, RegisterInput } from '@/types';

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  login: (credentials: LoginInput) => Promise<void>;
  register: (data: RegisterInput) => Promise<void>;
  logout: () => Promise<void>;
  fetchMe: () => Promise<void>;
  clearError: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      isAuthenticated: false,
      isLoading: false,
      error: null,

      login: async (credentials) => {
        set({ isLoading: true, error: null });
        try {
          await authApi.login(credentials);
          // Récupérer l'utilisateur complet après login
          const user = await authApi.me();
          set({ 
            user, 
            isAuthenticated: true, 
            isLoading: false 
          });
        } catch (error: any) {
          set({ 
            error: error.message || 'Erreur de connexion', 
            isLoading: false 
          });
          throw error;
        }
      },

      register: async (data) => {
        set({ isLoading: true, error: null });
        try {
          await authApi.register(data);
          // Récupérer l'utilisateur complet après inscription
          const user = await authApi.me();
          set({ 
            user, 
            isAuthenticated: true, 
            isLoading: false 
          });
        } catch (error: any) {
          set({ 
            error: error.message || 'Erreur lors de l\'inscription', 
            isLoading: false 
          });
          throw error;
        }
      },

      logout: async () => {
        set({ isLoading: true });
        try {
          await authApi.logout();
          set({ 
            user: null, 
            isAuthenticated: false, 
            isLoading: false,
            error: null 
          });
        } catch (error: any) {
          set({ 
            error: error.message || 'Erreur lors de la déconnexion', 
            isLoading: false 
          });
        }
      },

      fetchMe: async () => {
        set({ isLoading: true, error: null });
        try {
          const user = await authApi.me();
          set({ 
            user, 
            isAuthenticated: true, 
            isLoading: false 
          });
        } catch (error: any) {
          set({ 
            user: null,
            isAuthenticated: false,
            isLoading: false,
            error: error.message 
          });
        }
      },

      clearError: () => set({ error: null }),
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        isAuthenticated: state.isAuthenticated,
      }),
    }
  )
);/* eslint-disable @typescript-eslint/no-explicit-any */
import { create } from 'zustand';
import { avisApi } from '@/lib/api/avis';
import type { Avis, CreateAvisInput, AvisWithStats } from '@/types';

interface AvisState {
  avisWithStats: AvisWithStats | null;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  fetchUserAvis: (userId: number) => Promise<void>;
  createAvis: (data: CreateAvisInput) => Promise<Avis>;
  updateAvis: (id: number, data: CreateAvisInput) => Promise<void>;
  deleteAvis: (id: number) => Promise<void>;
  clearError: () => void;
  reset: () => void;
}

export const useAvisStore = create<AvisState>((set) => ({
  avisWithStats: null,
  isLoading: false,
  error: null,

  fetchUserAvis: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      const avisWithStats = await avisApi.byUser(userId);
      set({ avisWithStats, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des avis', 
        isLoading: false 
      });
    }
  },

  createAvis: async (data) => {
    set({ isLoading: true, error: null });
    try {
      const avis = await avisApi.create(data);
      set((state) => {
        if (!state.avisWithStats) return { isLoading: false };
        
        return {
          avisWithStats: {
            ...state.avisWithStats,
            avis: [avis, ...state.avisWithStats.avis],
            stats: {
              ...state.avisWithStats.stats,
              total: state.avisWithStats.stats.total + 1
            }
          },
          isLoading: false
        };
      });
      return avis;
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la création de l\'avis', 
        isLoading: false 
      });
      throw error;
    }
  },

  updateAvis: async (id, data) => {
    set({ isLoading: true, error: null });
    try {
      const updatedAvis = await avisApi.update(id, data);
      set((state) => {
        if (!state.avisWithStats) return { isLoading: false };
        
        return {
          avisWithStats: {
            ...state.avisWithStats,
            avis: state.avisWithStats.avis.map((a) => 
              a.id === id ? updatedAvis : a
            )
          },
          isLoading: false
        };
      });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la mise à jour de l\'avis', 
        isLoading: false 
      });
      throw error;
    }
  },

  deleteAvis: async (id) => {
    set({ isLoading: true, error: null });
    try {
      await avisApi.delete(id);
      set((state) => {
        if (!state.avisWithStats) return { isLoading: false };
        
        return {
          avisWithStats: {
            ...state.avisWithStats,
            avis: state.avisWithStats.avis.filter((a) => a.id !== id),
            stats: {
              ...state.avisWithStats.stats,
              total: Math.max(0, state.avisWithStats.stats.total - 1)
            }
          },
          isLoading: false
        };
      });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la suppression de l\'avis', 
        isLoading: false 
      });
      throw error;
    }
  },

  clearError: () => set({ error: null }),
  
  reset: () => set({ 
    avisWithStats: null,
    error: null 
  }),
}));/* eslint-disable @typescript-eslint/no-explicit-any */
import { create } from 'zustand';
import { demandesApi } from '@/lib/api/demandes';
import type { 
  Demande, 
  CreateDemandeInput, 
  UpdateDemandeInput, 
  DemandeFilters,
  DemandeStatut,
  PaginationMeta 
} from '@/types';

interface DemandeState {
  demandes: Demande[];
  currentDemande: Demande | null;
  pagination: PaginationMeta | null;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  fetchDemandes: (page?: number, limit?: number, filters?: DemandeFilters) => Promise<void>;
  fetchDemande: (id: number) => Promise<void>;
  createDemande: (data: CreateDemandeInput) => Promise<Demande>;
  updateDemande: (id: number, data: UpdateDemandeInput) => Promise<void>;
  updateStatus: (id: number, statut: DemandeStatut) => Promise<void>;
  deleteDemande: (id: number) => Promise<void>;
  fetchUserDemandes: (userId: number) => Promise<void>;
  clearError: () => void;
  reset: () => void;
}

export const useDemandeStore = create<DemandeState>((set) => ({
  demandes: [],
  currentDemande: null,
  pagination: null,
  isLoading: false,
  error: null,

  fetchDemandes: async (page = 1, limit = 10, filters) => {
    set({ isLoading: true, error: null });
    try {
      const response = await demandesApi.list(page, limit, filters);
      set({ 
        demandes: response.data, 
        pagination: response.pagination,
        isLoading: false 
      });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des demandes', 
        isLoading: false 
      });
    }
  },

  fetchDemande: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const demande = await demandesApi.show(id);
      set({ currentDemande: demande, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement de la demande', 
        isLoading: false 
      });
    }
  },

  createDemande: async (data) => {
    set({ isLoading: true, error: null });
    try {
      const demande = await demandesApi.create(data);
      set((state) => ({ 
        demandes: [demande, ...state.demandes],
        isLoading: false 
      }));
      return demande;
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la création de la demande', 
        isLoading: false 
      });
      throw error;
    }
  },

  updateDemande: async (id, data) => {
    set({ isLoading: true, error: null });
    try {
      const updatedDemande = await demandesApi.update(id, data);
      set((state) => ({
        demandes: state.demandes.map((d) => d.id === id ? updatedDemande : d),
        currentDemande: state.currentDemande?.id === id ? updatedDemande : state.currentDemande,
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la mise à jour de la demande', 
        isLoading: false 
      });
      throw error;
    }
  },

  updateStatus: async (id, statut) => {
    set({ isLoading: true, error: null });
    try {
      const updatedDemande = await demandesApi.updateStatus(id, statut);
      set((state) => ({
        demandes: state.demandes.map((d) => d.id === id ? updatedDemande : d),
        currentDemande: state.currentDemande?.id === id ? updatedDemande : state.currentDemande,
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la mise à jour du statut', 
        isLoading: false 
      });
      throw error;
    }
  },

  deleteDemande: async (id) => {
    set({ isLoading: true, error: null });
    try {
      await demandesApi.delete(id);
      set((state) => ({
        demandes: state.demandes.filter((d) => d.id !== id),
        currentDemande: state.currentDemande?.id === id ? null : state.currentDemande,
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la suppression de la demande', 
        isLoading: false 
      });
      throw error;
    }
  },

  fetchUserDemandes: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      const demandes = await demandesApi.byUser(userId);
      set({ demandes, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des demandes', 
        isLoading: false 
      });
    }
  },

  clearError: () => set({ error: null }),
  
  reset: () => set({ 
    demandes: [], 
    currentDemande: null, 
    pagination: null, 
    error: null 
  }),
}));/* eslint-disable @typescript-eslint/no-explicit-any */
import { create } from 'zustand';
import { favorisApi } from '@/lib/api/favoris';
import type { Favori } from '@/types';

interface FavoriState {
  favoris: Favori[];
  favorisVoyages: Favori[];
  favorisDemandes: Favori[];
  isLoading: boolean;
  error: string | null;
  
  // Actions
  fetchFavoris: () => Promise<void>;
  fetchFavorisVoyages: () => Promise<void>;
  fetchFavorisDemandes: () => Promise<void>;
  addVoyageToFavoris: (voyageId: number) => Promise<void>;
  addDemandeToFavoris: (demandeId: number) => Promise<void>;
  removeFavori: (id: number) => Promise<void>;
  isFavoriVoyage: (voyageId: number) => boolean;
  isFavoriDemande: (demandeId: number) => boolean;
  clearError: () => void;
  reset: () => void;
}

export const useFavoriStore = create<FavoriState>((set, get) => ({
  favoris: [],
  favorisVoyages: [],
  favorisDemandes: [],
  isLoading: false,
  error: null,

  fetchFavoris: async () => {
    set({ isLoading: true, error: null });
    try {
      const favoris = await favorisApi.list();
      set({ favoris, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des favoris', 
        isLoading: false 
      });
    }
  },

  fetchFavorisVoyages: async () => {
    set({ isLoading: true, error: null });
    try {
      const favorisVoyages = await favorisApi.getVoyages();
      set({ favorisVoyages, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des voyages favoris', 
        isLoading: false 
      });
    }
  },

  fetchFavorisDemandes: async () => {
    set({ isLoading: true, error: null });
    try {
      const favorisDemandes = await favorisApi.getDemandes();
      set({ favorisDemandes, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des demandes favorites', 
        isLoading: false 
      });
    }
  },

  addVoyageToFavoris: async (voyageId) => {
    set({ isLoading: true, error: null });
    try {
      const favori = await favorisApi.addVoyage(voyageId);
      set((state) => ({
        favoris: [...state.favoris, favori],
        favorisVoyages: [...state.favorisVoyages, favori],
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de l\'ajout aux favoris', 
        isLoading: false 
      });
      throw error;
    }
  },

  addDemandeToFavoris: async (demandeId) => {
    set({ isLoading: true, error: null });
    try {
      const favori = await favorisApi.addDemande(demandeId);
      set((state) => ({
        favoris: [...state.favoris, favori],
        favorisDemandes: [...state.favorisDemandes, favori],
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de l\'ajout aux favoris', 
        isLoading: false 
      });
      throw error;
    }
  },

  removeFavori: async (id) => {
    set({ isLoading: true, error: null });
    try {
      await favorisApi.remove(id);
      set((state) => ({
        favoris: state.favoris.filter((f) => f.id !== id),
        favorisVoyages: state.favorisVoyages.filter((f) => f.id !== id),
        favorisDemandes: state.favorisDemandes.filter((f) => f.id !== id),
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la suppression du favori', 
        isLoading: false 
      });
      throw error;
    }
  },

  isFavoriVoyage: (voyageId) => {
    const { favorisVoyages } = get();
    return favorisVoyages.some((f) => f.voyage?.id === voyageId);
  },

  isFavoriDemande: (demandeId) => {
    const { favorisDemandes } = get();
    return favorisDemandes.some((f) => f.demande?.id === demandeId);
  },

  clearError: () => set({ error: null }),
  
  reset: () => set({ 
    favoris: [],
    favorisVoyages: [],
    favorisDemandes: [],
    error: null 
  }),
}));/**
 * Export centralisé de tous les stores Zustand
 */

export { useAuthStore } from './authStore';
export { useVoyageStore } from './voyageStore';
export { useDemandeStore } from './demandeStore';
export { useMessageStore } from './messageStore';
export { useNotificationStore } from './notificationStore';
export { useUserStore } from './userStore';
export { useAvisStore } from './avisStore';
export { useFavoriStore } from './favoriStore';
export { useSignalementStore } from './signalementStore';/* eslint-disable @typescript-eslint/no-explicit-any */
import { create } from 'zustand';
import { messagesApi } from '@/lib/api/messages';
import type { Message, SendMessageInput, Conversation } from '@/types';

interface MessageState {
  conversations: Conversation[];
  currentConversation: Message[];
  unreadCount: number;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  fetchConversations: () => Promise<void>;
  fetchConversation: (userId: number) => Promise<void>;
  sendMessage: (data: SendMessageInput) => Promise<void>;
  markAsRead: (userId: number) => Promise<void>;
  fetchUnreadCount: () => Promise<void>;
  deleteMessage: (id: number) => Promise<void>;
  clearError: () => void;
  reset: () => void;
}

export const useMessageStore = create<MessageState>((set) => ({
  conversations: [],
  currentConversation: [],
  unreadCount: 0,
  isLoading: false,
  error: null,

  fetchConversations: async () => {
    set({ isLoading: true, error: null });
    try {
      const conversations = await messagesApi.getConversations();
      set({ conversations, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des conversations', 
        isLoading: false 
      });
    }
  },

  fetchConversation: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      const messages = await messagesApi.getConversation(userId);
      set({ currentConversation: messages, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement de la conversation', 
        isLoading: false 
      });
    }
  },

  sendMessage: async (data) => {
    set({ isLoading: true, error: null });
    try {
      const message = await messagesApi.send(data);
      set((state) => ({
        currentConversation: [...state.currentConversation, message],
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de l\'envoi du message', 
        isLoading: false 
      });
      throw error;
    }
  },

  markAsRead: async (userId) => {
    try {
      await messagesApi.markAsRead(userId);
      set((state) => ({
        currentConversation: state.currentConversation.map((msg) => ({
          ...msg,
          lu: msg.destinataire.id === userId ? true : msg.lu
        }))
      }));
      // Rafraîchir le compteur
      const unreadCount = await messagesApi.getUnreadCount();
      set({ unreadCount });
    } catch (error: any) {
      set({ error: error.message });
    }
  },

  fetchUnreadCount: async () => {
    try {
      const unreadCount = await messagesApi.getUnreadCount();
      set({ unreadCount });
    } catch (error: any) {
      console.error('Erreur compteur messages non lus:', error);
    }
  },

  deleteMessage: async (id) => {
    set({ isLoading: true, error: null });
    try {
      await messagesApi.delete(id);
      set((state) => ({
        currentConversation: state.currentConversation.filter((msg) => msg.id !== id),
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la suppression du message', 
        isLoading: false 
      });
      throw error;
    }
  },

  clearError: () => set({ error: null }),
  
  reset: () => set({ 
    conversations: [], 
    currentConversation: [], 
    unreadCount: 0,
    error: null 
  }),
}));/* eslint-disable @typescript-eslint/no-explicit-any */
import { create } from 'zustand';
import { notificationsApi } from '@/lib/api/notifications';
import type { Notification } from '@/types';

interface NotificationState {
  notifications: Notification[];
  unreadCount: number;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  fetchNotifications: () => Promise<void>;
  fetchUnread: () => Promise<void>;
  fetchUnreadCount: () => Promise<void>;
  markAsRead: (id: number) => Promise<void>;
  markAllAsRead: () => Promise<void>;
  deleteNotification: (id: number) => Promise<void>;
  clearError: () => void;
  reset: () => void;
}

export const useNotificationStore = create<NotificationState>((set) => ({
  notifications: [],
  unreadCount: 0,
  isLoading: false,
  error: null,

  fetchNotifications: async () => {
    set({ isLoading: true, error: null });
    try {
      const notifications = await notificationsApi.list();
      set({ notifications, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des notifications', 
        isLoading: false 
      });
    }
  },

  fetchUnread: async () => {
    set({ isLoading: true, error: null });
    try {
      const notifications = await notificationsApi.getUnread();
      set({ notifications, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des notifications', 
        isLoading: false 
      });
    }
  },

  fetchUnreadCount: async () => {
    try {
      const unreadCount = await notificationsApi.getUnreadCount();
      set({ unreadCount });
    } catch (error: any) {
      console.error('Erreur compteur notifications:', error);
    }
  },

  markAsRead: async (id) => {
    try {
      await notificationsApi.markAsRead(id);
      set((state) => ({
        notifications: state.notifications.map((notif) =>
          notif.id === id ? { ...notif, lue: true } : notif
        ),
        unreadCount: Math.max(0, state.unreadCount - 1)
      }));
    } catch (error: any) {
      set({ error: error.message });
    }
  },

  markAllAsRead: async () => {
    set({ isLoading: true, error: null });
    try {
      await notificationsApi.markAllAsRead();
      set((state) => ({
        notifications: state.notifications.map((notif) => ({ ...notif, lue: true })),
        unreadCount: 0,
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du marquage des notifications', 
        isLoading: false 
      });
    }
  },

  deleteNotification: async (id) => {
    try {
      await notificationsApi.delete(id);
      set((state) => {
        const notification = state.notifications.find((n) => n.id === id);
        const wasUnread = notification && !notification.lue;
        
        return {
          notifications: state.notifications.filter((n) => n.id !== id),
          unreadCount: wasUnread ? Math.max(0, state.unreadCount - 1) : state.unreadCount
        };
      });
    } catch (error: any) {
      set({ error: error.message });
      throw error;
    }
  },

  clearError: () => set({ error: null }),
  
  reset: () => set({ 
    notifications: [], 
    unreadCount: 0,
    error: null 
  }),
}));/* eslint-disable @typescript-eslint/no-explicit-any */
import { create } from 'zustand';
import { signalementsApi } from '@/lib/api/signalement';
import type { 
  Signalement, 
  CreateSignalementInput, 
  TraiterSignalementInput,
  PaginationMeta 
} from '@/types';

interface SignalementState {
  signalements: Signalement[];
  currentSignalement: Signalement | null;
  pagination: PaginationMeta | null;
  pendingCount: number;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  fetchSignalements: (page?: number, limit?: number, statut?: string) => Promise<void>;
  createSignalement: (data: CreateSignalementInput) => Promise<Signalement>;
  processSignalement: (id: number, data: TraiterSignalementInput) => Promise<void>;
  fetchPendingCount: () => Promise<void>;
  clearError: () => void;
  reset: () => void;
}

export const useSignalementStore = create<SignalementState>((set) => ({
  signalements: [],
  currentSignalement: null,
  pagination: null,
  pendingCount: 0,
  isLoading: false,
  error: null,

  fetchSignalements: async (page = 1, limit = 10, statut) => {
    set({ isLoading: true, error: null });
    try {
      const response = await signalementsApi.list(page, limit, statut);
      set({ 
        signalements: response.data, 
        pagination: response.pagination,
        isLoading: false 
      });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des signalements', 
        isLoading: false 
      });
    }
  },

  createSignalement: async (data) => {
    set({ isLoading: true, error: null });
    try {
      const signalement = await signalementsApi.create(data);
      set((state) => ({
        signalements: [signalement, ...state.signalements],
        pendingCount: state.pendingCount + 1,
        isLoading: false
      }));
      return signalement;
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la création du signalement', 
        isLoading: false 
      });
      throw error;
    }
  },

  processSignalement: async (id, data) => {
    set({ isLoading: true, error: null });
    try {
      const updatedSignalement = await signalementsApi.process(id, data);
      set((state) => ({
        signalements: state.signalements.map((s) => 
          s.id === id ? updatedSignalement : s
        ),
        currentSignalement: state.currentSignalement?.id === id 
          ? updatedSignalement 
          : state.currentSignalement,
        pendingCount: Math.max(0, state.pendingCount - 1),
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du traitement du signalement', 
        isLoading: false 
      });
      throw error;
    }
  },

  fetchPendingCount: async () => {
    try {
      const pendingCount = await signalementsApi.getPendingCount();
      set({ pendingCount });
    } catch (error: any) {
      console.error('Erreur compteur signalements:', error);
    }
  },

  clearError: () => set({ error: null }),
  
  reset: () => set({ 
    signalements: [],
    currentSignalement: null,
    pagination: null,
    pendingCount: 0,
    error: null 
  }),
}));/* eslint-disable @typescript-eslint/no-explicit-any */
import { create } from 'zustand';
import { usersApi } from '@/lib/api/users';
import type { User, UpdateUserInput, PaginationMeta } from '@/types';

interface UserState {
  users: User[];
  currentUser: User | null;
  pagination: PaginationMeta | null;
  searchResults: User[];
  isLoading: boolean;
  error: string | null;
  
  // Actions
  fetchUsers: (page?: number, limit?: number) => Promise<void>;
  fetchUser: (id: number) => Promise<void>;
  updateMe: (data: UpdateUserInput) => Promise<void>;
  searchUsers: (query: string) => Promise<void>;
  clearError: () => void;
  reset: () => void;
}

export const useUserStore = create<UserState>((set) => ({
  users: [],
  currentUser: null,
  pagination: null,
  searchResults: [],
  isLoading: false,
  error: null,

  fetchUsers: async (page = 1, limit = 10) => {
    set({ isLoading: true, error: null });
    try {
      const response = await usersApi.list(page, limit);
      set({ 
        users: response.data, 
        pagination: response.pagination,
        isLoading: false 
      });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des utilisateurs', 
        isLoading: false 
      });
    }
  },

  fetchUser: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const user = await usersApi.show(id);
      set({ currentUser: user, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement de l\'utilisateur', 
        isLoading: false 
      });
    }
  },

  updateMe: async (data) => {
    set({ isLoading: true, error: null });
    try {
      const user = await usersApi.updateMe(data);
      set({ currentUser: user, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la mise à jour du profil', 
        isLoading: false 
      });
      throw error;
    }
  },

  searchUsers: async (query) => {
    set({ isLoading: true, error: null });
    try {
      const searchResults = await usersApi.search(query);
      set({ searchResults, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la recherche', 
        isLoading: false 
      });
    }
  },

  clearError: () => set({ error: null }),
  
  reset: () => set({ 
    users: [], 
    currentUser: null, 
    pagination: null,
    searchResults: [],
    error: null 
  }),
}));/* eslint-disable @typescript-eslint/no-explicit-any */
import { create } from 'zustand';
import { voyagesApi } from '@/lib/api/voyages';
import type { 
  Voyage, 
  CreateVoyageInput, 
  UpdateVoyageInput, 
  VoyageFilters, 
  VoyageStatut,
  PaginationMeta 
} from '@/types';

interface VoyageState {
  voyages: Voyage[];
  currentVoyage: Voyage | null;
  pagination: PaginationMeta | null;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  fetchVoyages: (page?: number, limit?: number, filters?: VoyageFilters) => Promise<void>;
  fetchVoyage: (id: number) => Promise<void>;
  createVoyage: (data: CreateVoyageInput) => Promise<Voyage>;
  updateVoyage: (id: number, data: UpdateVoyageInput) => Promise<void>;
  updateStatus: (id: number, statut: VoyageStatut) => Promise<void>;
  deleteVoyage: (id: number) => Promise<void>;
  fetchUserVoyages: (userId: number) => Promise<void>;
  clearError: () => void;
  reset: () => void;
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export const useVoyageStore = create<VoyageState>((set, get) => ({
  voyages: [],
  currentVoyage: null,
  pagination: null,
  isLoading: false,
  error: null,

  fetchVoyages: async (page = 1, limit = 10, filters) => {
    set({ isLoading: true, error: null });
    try {
      const response = await voyagesApi.list(page, limit, filters);
      set({ 
        voyages: response.data, 
        pagination: response.pagination,
        isLoading: false 
      });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des voyages', 
        isLoading: false 
      });
    }
  },

  fetchVoyage: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const voyage = await voyagesApi.show(id);
      set({ currentVoyage: voyage, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement du voyage', 
        isLoading: false 
      });
    }
  },

  createVoyage: async (data) => {
    set({ isLoading: true, error: null });
    try {
      const voyage = await voyagesApi.create(data);
      set((state) => ({ 
        voyages: [voyage, ...state.voyages],
        isLoading: false 
      }));
      return voyage;
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la création du voyage', 
        isLoading: false 
      });
      throw error;
    }
  },

  updateVoyage: async (id, data) => {
    set({ isLoading: true, error: null });
    try {
      const updatedVoyage = await voyagesApi.update(id, data);
      set((state) => ({
        voyages: state.voyages.map((v) => v.id === id ? updatedVoyage : v),
        currentVoyage: state.currentVoyage?.id === id ? updatedVoyage : state.currentVoyage,
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la mise à jour du voyage', 
        isLoading: false 
      });
      throw error;
    }
  },

  updateStatus: async (id, statut) => {
    set({ isLoading: true, error: null });
    try {
      const updatedVoyage = await voyagesApi.updateStatus(id, statut);
      set((state) => ({
        voyages: state.voyages.map((v) => v.id === id ? updatedVoyage : v),
        currentVoyage: state.currentVoyage?.id === id ? updatedVoyage : state.currentVoyage,
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la mise à jour du statut', 
        isLoading: false 
      });
      throw error;
    }
  },

  deleteVoyage: async (id) => {
    set({ isLoading: true, error: null });
    try {
      await voyagesApi.delete(id);
      set((state) => ({
        voyages: state.voyages.filter((v) => v.id !== id),
        currentVoyage: state.currentVoyage?.id === id ? null : state.currentVoyage,
        isLoading: false
      }));
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors de la suppression du voyage', 
        isLoading: false 
      });
      throw error;
    }
  },

  fetchUserVoyages: async (userId) => {
    set({ isLoading: true, error: null });
    try {
      const voyages = await voyagesApi.byUser(userId);
      set({ voyages, isLoading: false });
    } catch (error: any) {
      set({ 
        error: error.message || 'Erreur lors du chargement des voyages', 
        isLoading: false 
      });
    }
  },

  clearError: () => set({ error: null }),
  
  reset: () => set({ 
    voyages: [], 
    currentVoyage: null, 
    pagination: null, 
    error: null 
  }),
}));